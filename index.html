<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Crypto Äpp</title>
    <style>
        div {
            width:100%;
            text-align:center;
            padding-top: 5px;
        }
        img {
            padding: 15px;
        }
        textarea {
            vertical-align: bottom;
        }
    </style>
    <script>
        /** Script used from https://www.movable-type.co.uk/scripts/sha512.html*/
        /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
        /* SHA-512 (FIPS 180-4) implementation in JavaScript                  (c) Chris Veness 2016-2018  */
        /*                                                                                   MIT Licence  */
        /* www.movable-type.co.uk/scripts/sha512.html                                                     */
        /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */


        /**
         * SHA-512 hash function reference implementation.
         *
         * This is an annotated direct implementation of FIPS 180-4, without any optimisations. It is
         * intended to aid understanding of the algorithm rather than for production use.
         *
         * While it could be used where performance is not critical, I would recommend using the ‘Web
         * Cryptography API’ (developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest) for the browser,
         * or the ‘crypto’ library (nodejs.org/api/crypto.html#crypto_class_hash) in Node.js.
         *
         * SHA-512 is more difficult to implement in JavaScript than SHA-256, as it is based on 64-bit
         * (unsigned) integers, which are not natively supported in JavaScript (in which all numbers are
         * IEEE 754 64-bit floating-point numbers). A 'Long' library here provides UInt64-style support.
         *
         * See csrc.nist.gov/groups/ST/toolkit/secure_hashing.html
         *     csrc.nist.gov/groups/ST/toolkit/examples.html
         */
        class Sha512 {

            /**
             * Generates SHA-512 hash of string.
             *
             * @param   {string} msg - (Unicode) string to be hashed.
             * @param   {Object} [options]
             * @param   {string} [options.msgFormat=string] - Message format: 'string' for JavaScript string
             *   (gets converted to UTF-8 for hashing); 'hex-bytes' for string of hex bytes ('616263' ≡ 'abc') .
             * @param   {string} [options.outFormat=hex] - Output format: 'hex' for string of contiguous
             *   hex bytes; 'hex-w' for grouping hex bytes into groups of (8 byte / 16 character) words.
             * @returns {string} Hash of msg as hex character string.
             */
            static hash(msg, options) {
                const defaults = { msgFormat: 'string', outFormat: 'hex' };
                const opt = Object.assign(defaults, options);

                switch (opt.msgFormat) {
                    default: // default is to convert string to UTF-8, as SHA only deals with byte-streams
                    case 'string':   msg = utf8Encode(msg);       break;
                    case 'hex-bytes':msg = hexBytesToString(msg); break; // mostly for running tests
                }

                // constants [§4.2.3]
                const K = [
                    '428a2f98d728ae22', '7137449123ef65cd', 'b5c0fbcfec4d3b2f', 'e9b5dba58189dbbc',
                    '3956c25bf348b538', '59f111f1b605d019', '923f82a4af194f9b', 'ab1c5ed5da6d8118',
                    'd807aa98a3030242', '12835b0145706fbe', '243185be4ee4b28c', '550c7dc3d5ffb4e2',
                    '72be5d74f27b896f', '80deb1fe3b1696b1', '9bdc06a725c71235', 'c19bf174cf692694',
                    'e49b69c19ef14ad2', 'efbe4786384f25e3', '0fc19dc68b8cd5b5', '240ca1cc77ac9c65',
                    '2de92c6f592b0275', '4a7484aa6ea6e483', '5cb0a9dcbd41fbd4', '76f988da831153b5',
                    '983e5152ee66dfab', 'a831c66d2db43210', 'b00327c898fb213f', 'bf597fc7beef0ee4',
                    'c6e00bf33da88fc2', 'd5a79147930aa725', '06ca6351e003826f', '142929670a0e6e70',
                    '27b70a8546d22ffc', '2e1b21385c26c926', '4d2c6dfc5ac42aed', '53380d139d95b3df',
                    '650a73548baf63de', '766a0abb3c77b2a8', '81c2c92e47edaee6', '92722c851482353b',
                    'a2bfe8a14cf10364', 'a81a664bbc423001', 'c24b8b70d0f89791', 'c76c51a30654be30',
                    'd192e819d6ef5218', 'd69906245565a910', 'f40e35855771202a', '106aa07032bbd1b8',
                    '19a4c116b8d2d0c8', '1e376c085141ab53', '2748774cdf8eeb99', '34b0bcb5e19b48a8',
                    '391c0cb3c5c95a63', '4ed8aa4ae3418acb', '5b9cca4f7763e373', '682e6ff3d6b2b8a3',
                    '748f82ee5defb2fc', '78a5636f43172f60', '84c87814a1f0ab72', '8cc702081a6439ec',
                    '90befffa23631e28', 'a4506cebde82bde9', 'bef9a3f7b2c67915', 'c67178f2e372532b',
                    'ca273eceea26619c', 'd186b8c721c0c207', 'eada7dd6cde0eb1e', 'f57d4f7fee6ed178',
                    '06f067aa72176fba', '0a637dc5a2c898a6', '113f9804bef90dae', '1b710b35131c471b',
                    '28db77f523047d84', '32caab7b40c72493', '3c9ebe0a15c9bebc', '431d67c49c100d4c',
                    '4cc5d4becb3e42b6', '597f299cfc657e2a', '5fcb6fab3ad6faec', '6c44198c4a475817',
                ].map(k => Sha512.Long.fromString(k));

                // initial hash value [§5.3.5]
                const H = [
                    '6a09e667f3bcc908', 'bb67ae8584caa73b', '3c6ef372fe94f82b', 'a54ff53a5f1d36f1',
                    '510e527fade682d1', '9b05688c2b3e6c1f', '1f83d9abfb41bd6b', '5be0cd19137e2179',
                ].map(h => Sha512.Long.fromString(h));

                // PREPROCESSING [§6.4.1]

                msg += String.fromCharCode(0x80);  // add trailing '1' bit (+ 0's padding) to string [§5.1.2]

                // convert string msg into 1024-bit blocks (array of 16 uint64) [§5.2.2]
                const l = msg.length/8 + 2; // length (in 64-bit longs) of msg + ‘1’ + appended length
                const N = Math.ceil(l/16);  // number of 16-long (1024-bit) blocks required to hold 'l' ints
                const M = new Array(N);     // message M is N×16 array of 64-bit integers

                for (let i=0; i<N; i++) {
                    M[i] = new Array(16);
                    for (let j=0; j<16; j++) { // encode 8 chars per uint64 (128 per block), big-endian encoding
                        const lo = (msg.charCodeAt(i*128+j*8)<<24) | (msg.charCodeAt(i*128+j*8+1)<<16)
                            | (msg.charCodeAt(i*128+j*8+2)<< 8) | (msg.charCodeAt(i*128+j*8+3)<< 0);
                        const hi = (msg.charCodeAt(i*128+j*8+4)<<24) | (msg.charCodeAt(i*128+j*8+5)<<16)
                            | (msg.charCodeAt(i*128+j*8+6)<< 8) | (msg.charCodeAt(i*128+j*8+7)<< 0);
                        M[i][j] = new Sha512.Long(lo, hi);
                    } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0
                }
                // add length (in bits) into final pair of 64-bit integers (big-endian) [§5.1.2]
                M[N-1][14] = new Sha512.Long(0, 0); // tooo hard... limit msg to 2 million terabytes
                // note: most significant word would be (len-1)*8 >>> 32, but since JS converts
                // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators
                const lenHi = ((msg.length-1)*8) / Math.pow(2, 32);
                const lenLo = ((msg.length-1)*8) >>> 0; // note '>>> 0' coerces number to unsigned 32-bit integer
                M[N-1][15] = new Sha512.Long(Math.floor(lenHi), lenLo);


                // HASH COMPUTATION [§6.4.2]

                for (let i=0; i<N; i++) {
                    const W = new Array(80);

                    // 1 - prepare message schedule 'W'
                    for (let t=0;  t<16; t++) W[t] = M[i][t];
                    for (let t=16; t<80; t++) {
                        W[t] = (Sha512.σ1(W[t-2]).add(W[t-7]).add(Sha512.σ0(W[t-15])).add(W[t-16]));
                    }

                    // 2 - initialise working variables a, b, c, d, e, f, g, h with previous hash value
                    let a = H[0], b = H[1], c = H[2], d = H[3], e = H[4], f = H[5], g = H[6], h = H[7];

                    // 3 - main loop (note 'addition modulo 2^64')
                    for (let t=0; t<80; t++) {
                        const T1 = h.add(Sha512.Σ1(e)).add(Sha512.Ch(e, f, g)).add(K[t]).add(W[t]);
                        const T2 = Sha512.Σ0(a).add(Sha512.Maj(a, b, c));
                        h = g;
                        g = f;
                        f = e;
                        e = d.add(T1);
                        d = c;
                        c = b;
                        b = a;
                        a = T1.add(T2);
                    }

                    // 4 - compute the new intermediate hash value
                    H[0] = H[0].add(a);
                    H[1] = H[1].add(b);
                    H[2] = H[2].add(c);
                    H[3] = H[3].add(d);
                    H[4] = H[4].add(e);
                    H[5] = H[5].add(f);
                    H[6] = H[6].add(g);
                    H[7] = H[7].add(h);
                }

                // convert H0..H7 to hex strings (with leading zeros)
                for (let h=0; h<H.length; h++) H[h] = H[h].toString();

                // concatenate H0..H7, with separator if required
                const separator = opt.outFormat==='hex-w' ? ' ' : '';

                return H.join(separator);

                /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

                function utf8Encode(str) {
                    try {
                        return new TextEncoder().encode(str, 'utf-8').reduce((prev, curr) => prev + String.fromCharCode(curr), '');
                    } catch (e) { // no TextEncoder available?
                        return unescape(encodeURIComponent(str)); // monsur.hossa.in/2012/07/20/utf-8-in-javascript.html
                    }
                }

                function hexBytesToString(hexStr) { // convert string of hex numbers to a string of chars (eg '616263' -> 'abc').
                    const str = hexStr.replace(' ', ''); // allow space-separated groups
                    return str==='' ? '' :
                        str.match(/.{2}/g).map(byte => String.fromCharCode(parseInt(byte, 16))).join('');
                }
            }


            /**
             * Rotates right (circular right shift) value x by n positions [§3.2.4].
             * @private
             */
            static ROTR(x, n) { // emulates (x >>> n) | (x << (64-n)
                if (n === 0) return x;
                if (n === 32) return new Sha512.Long(x.lo, x.hi);

                let hi = x.hi, lo = x.lo;

                if (n > 32) {
                    [ lo, hi ] = [ hi, lo ]; // swap hi/lo
                    n -= 32;
                }

                const hi1 = (hi >>> n) | (lo << (32-n));
                const lo1 = (lo >>> n) | (hi << (32-n));

                return new Sha512.Long(hi1, lo1);
            }


            /**
             * Logical functions [§4.1.3].
             * @private
             */
            static Σ0(x) { return Sha512.ROTR(x, 28).xor(Sha512.ROTR(x, 34)).xor(Sha512.ROTR(x, 39)); }
            static Σ1(x) { return Sha512.ROTR(x, 14).xor(Sha512.ROTR(x, 18)).xor(Sha512.ROTR(x, 41)); }
            static σ0(x) { return Sha512.ROTR(x,  1).xor(Sha512.ROTR(x,  8)).xor(x.shr(7)); }
            static σ1(x) { return Sha512.ROTR(x, 19).xor(Sha512.ROTR(x, 61)).xor(x.shr(6)); }
            static Ch(x, y, z)  { return (x.and(y)).xor(x.not().and(z)); }         // 'choice'
            static Maj(x, y, z) { return (x.and(y)).xor(x.and(z)).xor(y.and(z)); } // 'majority'

        }



        /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

        /**
         * JavaScript has no support for 64-bit integers; this class provides methods required to support
         * 64-bit unsigned integers within Sha256.
         *
         * All string manipulation is radix 16. Note n >>> 0 coerces n to unsigned 32-bit value.
         */
        Sha512.Long = class {

            constructor(hi, lo) {
                this.hi = hi >>> 0;
                this.lo = lo >>> 0;
            }

            static fromString(str) {
                const hi = parseInt(str.slice(0, -8), 16);
                const lo = parseInt(str.slice(-8), 16);

                return new Sha512.Long(hi, lo);
            }

            toString() {
                const hi = ('00000000'+this.hi.toString(16)).slice(-8);
                const lo = ('00000000'+this.lo.toString(16)).slice(-8);

                return hi + lo;
            }

            add(that) { // addition modulo 2^64
                const lo = this.lo + that.lo;
                const hi = this.hi + that.hi + (lo>0x100000000 ? 1 : 0); // carry top bit if lo > 2^32

                return new Sha512.Long(hi >>> 0, lo >>> 0);
            }

            and(that) { // &
                return new Sha512.Long(this.hi & that.hi, this.lo & that.lo);
            }

            xor(that) { // ^
                return new Sha512.Long(this.hi ^ that.hi, this.lo ^ that.lo);
            }

            not() {  // ~
                return new Sha512.Long(~this.hi, ~this.lo);
            }

            shr(n) { // >>>
                if (n ===  0) return this;
                if (n === 32) return new Sha512.Long(0, this.hi);
                if (n >  32) return new Sha512.Long(0, this.hi >>> n-32);
                /* n < 32 */ return new Sha512.Long(this.hi >>> n, this.lo >>> n | this.hi << (32-n));
            }

        };


        /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

        //export default Sha512;
    </script>
    <script>
        /* Used code from http://www.myersdaily.org/joseph/javascript/md5-text.html*/
        function md5cycle(x, k) {
            let a = x[0], b = x[1], c = x[2], d = x[3];

            a = ff(a, b, c, d, k[0], 7, -680876936);
            d = ff(d, a, b, c, k[1], 12, -389564586);
            c = ff(c, d, a, b, k[2], 17,  606105819);
            b = ff(b, c, d, a, k[3], 22, -1044525330);
            a = ff(a, b, c, d, k[4], 7, -176418897);
            d = ff(d, a, b, c, k[5], 12,  1200080426);
            c = ff(c, d, a, b, k[6], 17, -1473231341);
            b = ff(b, c, d, a, k[7], 22, -45705983);
            a = ff(a, b, c, d, k[8], 7,  1770035416);
            d = ff(d, a, b, c, k[9], 12, -1958414417);
            c = ff(c, d, a, b, k[10], 17, -42063);
            b = ff(b, c, d, a, k[11], 22, -1990404162);
            a = ff(a, b, c, d, k[12], 7,  1804603682);
            d = ff(d, a, b, c, k[13], 12, -40341101);
            c = ff(c, d, a, b, k[14], 17, -1502002290);
            b = ff(b, c, d, a, k[15], 22,  1236535329);

            a = gg(a, b, c, d, k[1], 5, -165796510);
            d = gg(d, a, b, c, k[6], 9, -1069501632);
            c = gg(c, d, a, b, k[11], 14,  643717713);
            b = gg(b, c, d, a, k[0], 20, -373897302);
            a = gg(a, b, c, d, k[5], 5, -701558691);
            d = gg(d, a, b, c, k[10], 9,  38016083);
            c = gg(c, d, a, b, k[15], 14, -660478335);
            b = gg(b, c, d, a, k[4], 20, -405537848);
            a = gg(a, b, c, d, k[9], 5,  568446438);
            d = gg(d, a, b, c, k[14], 9, -1019803690);
            c = gg(c, d, a, b, k[3], 14, -187363961);
            b = gg(b, c, d, a, k[8], 20,  1163531501);
            a = gg(a, b, c, d, k[13], 5, -1444681467);
            d = gg(d, a, b, c, k[2], 9, -51403784);
            c = gg(c, d, a, b, k[7], 14,  1735328473);
            b = gg(b, c, d, a, k[12], 20, -1926607734);

            a = hh(a, b, c, d, k[5], 4, -378558);
            d = hh(d, a, b, c, k[8], 11, -2022574463);
            c = hh(c, d, a, b, k[11], 16,  1839030562);
            b = hh(b, c, d, a, k[14], 23, -35309556);
            a = hh(a, b, c, d, k[1], 4, -1530992060);
            d = hh(d, a, b, c, k[4], 11,  1272893353);
            c = hh(c, d, a, b, k[7], 16, -155497632);
            b = hh(b, c, d, a, k[10], 23, -1094730640);
            a = hh(a, b, c, d, k[13], 4,  681279174);
            d = hh(d, a, b, c, k[0], 11, -358537222);
            c = hh(c, d, a, b, k[3], 16, -722521979);
            b = hh(b, c, d, a, k[6], 23,  76029189);
            a = hh(a, b, c, d, k[9], 4, -640364487);
            d = hh(d, a, b, c, k[12], 11, -421815835);
            c = hh(c, d, a, b, k[15], 16,  530742520);
            b = hh(b, c, d, a, k[2], 23, -995338651);

            a = ii(a, b, c, d, k[0], 6, -198630844);
            d = ii(d, a, b, c, k[7], 10,  1126891415);
            c = ii(c, d, a, b, k[14], 15, -1416354905);
            b = ii(b, c, d, a, k[5], 21, -57434055);
            a = ii(a, b, c, d, k[12], 6,  1700485571);
            d = ii(d, a, b, c, k[3], 10, -1894986606);
            c = ii(c, d, a, b, k[10], 15, -1051523);
            b = ii(b, c, d, a, k[1], 21, -2054922799);
            a = ii(a, b, c, d, k[8], 6,  1873313359);
            d = ii(d, a, b, c, k[15], 10, -30611744);
            c = ii(c, d, a, b, k[6], 15, -1560198380);
            b = ii(b, c, d, a, k[13], 21,  1309151649);
            a = ii(a, b, c, d, k[4], 6, -145523070);
            d = ii(d, a, b, c, k[11], 10, -1120210379);
            c = ii(c, d, a, b, k[2], 15,  718787259);
            b = ii(b, c, d, a, k[9], 21, -343485551);

            x[0] = add32(a, x[0]);
            x[1] = add32(b, x[1]);
            x[2] = add32(c, x[2]);
            x[3] = add32(d, x[3]);

        }

        function cmn(q, a, b, x, s, t) {
            a = add32(add32(a, q), add32(x, t));
            return add32((a << s) | (a >>> (32 - s)), b);
        }

        function ff(a, b, c, d, x, s, t) {
            return cmn((b & c) | ((~b) & d), a, b, x, s, t);
        }

        function gg(a, b, c, d, x, s, t) {
            return cmn((b & d) | (c & (~d)), a, b, x, s, t);
        }

        function hh(a, b, c, d, x, s, t) {
            return cmn(b ^ c ^ d, a, b, x, s, t);
        }

        function ii(a, b, c, d, x, s, t) {
            return cmn(c ^ (b | (~d)), a, b, x, s, t);
        }

        function md51(s) {
            let txt = '';
            let n = s.length,
                state = [1732584193, -271733879, -1732584194, 271733878], i;
            for (i=64; i<=s.length; i+=64) {
                md5cycle(state, md5blk(s.substring(i-64, i)));
            }
            s = s.substring(i-64);
            let tail = [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0];
            for (i=0; i<s.length; i++)
                tail[i>>2] |= s.charCodeAt(i) << ((i%4) << 3);
            tail[i>>2] |= 0x80 << ((i%4) << 3);
            if (i > 55) {
                md5cycle(state, tail);
                for (i=0; i<16; i++) tail[i] = 0;
            }
            tail[14] = n*8;
            md5cycle(state, tail);
            return state;
        }

        /* there needs to be support for Unicode here,
         * unless we pretend that we can redefine the MD-5
         * algorithm for multi-byte characters (perhaps
         * by adding every four 16-bit characters and
         * shortening the sum to 32 bits). Otherwise
         * I suggest performing MD-5 as if every character
         * was two bytes--e.g., 0040 0025 = @%--but then
         * how will an ordinary MD-5 sum be matched?
         * There is no way to standardize text to something
         * like UTF-8 before transformation; speed cost is
         * utterly prohibitive. The JavaScript standard
         * itself needs to look at this: it should start
         * providing access to strings as preformed UTF-8
         * 8-bit unsigned value arrays.
         */
        function md5blk(s) { /* I figured global was faster.   */
            let md5blks = [], i; /* Andy King said do it this way. */
            for (i=0; i<64; i+=4) {
                md5blks[i>>2] = s.charCodeAt(i)
                    + (s.charCodeAt(i+1) << 8)
                    + (s.charCodeAt(i+2) << 16)
                    + (s.charCodeAt(i+3) << 24);
            }
            return md5blks;
        }

        let hex_chr = '0123456789abcdef'.split('');

        function rhex(n)
        {
            let s='', j=0;
            for(; j<4; j++)
                s += hex_chr[(n >> (j * 8 + 4)) & 0x0F]
                    + hex_chr[(n >> (j * 8)) & 0x0F];
            return s;
        }

        function hex(x) {
            for (let i=0; i<x.length; i++)
                x[i] = rhex(x[i]);
            return x.join('');
        }

        function md5(s) {
            return hex(md51(s));
        }

        /* this function is much faster,
        so if possible we use it. Some IEs
        are the only ones I know of that
        need the idiotic second function,
        generated by an if clause.  */

        function add32(a, b) {
            return (a + b) & 0xFFFFFFFF;
        }

        if (md5('hello') !== '5d41402abc4b2a76b9719d911017c592') {
            function add32(x, y) {
                let lsw = (x & 0xFFFF) + (y & 0xFFFF),
                    msw = (x >> 16) + (y >> 16) + (lsw >> 16);
                return (msw << 16) | (lsw & 0xFFFF);
            }
        }
    </script>
    <script>
        function try_combinations(string, hash)
        {
            let found = false;
            let next;
            let loop = function (depth, prefix, s_length)
            {
                for(let i = 0; i < s_length && !found; i++)
                {
                    next = prefix + string[i];
                    if (depth > 0)
                        loop(depth - 1, next, s_length);
                    else if (hash === md5(next)){
                        found = true;
                    }
                }
                if (found)
                    return next;
                else
                    return "Unable to crack.";
            };

            let result;
            for(let i = 0; i < 5 && !found; i++) { // Max 6 characters.
                //document.getElementById("output").innerText = "Checking codes with " + i + " characters...";
                result = loop(i, '', string.length);
            }
            return result;
        }
    </script>
    <script>
        function otp(encode) {
            const input = document.getElementById("input").innerText;
            const key = document.getElementById("key").innerText;

            if (key.length < input.length){
                alert("Key is too short, must be at least the length of input");
                return;
            }

            let encoded = [];
            for (let i = 0; i < input.length; i++){
                encoded.push(String.fromCharCode((input.charCodeAt(i) + key.charCodeAt(i) * (encode ? 1 : -1)) %
                    65536));
            }
            document.getElementById("output").innerText = encoded.join("");
        }

        function sha512() {
            const input = document.getElementById("input").innerText;
            document.getElementById("output").innerText = Sha512.hash(input).toString();
        }
        
        function md5_decrypt() {
            const hash = document.getElementById("input").innerText;
            document.getElementById("output").innerText = try_combinations("abcdefghijklmnopqrstuvwxyz", hash);
        }
    </script>
</head>
<body>
    <div id="div_image">
        <img id=image" src="image.jpg">
    </div>
    <div>
        <h4>Input:</h4>
        <textarea id="input" rows="10" cols="80">Input</textarea>
    </div>
    <div class="inline">
        <h4 style=" display: inline">Key:</h4>
        <textarea id="key" rows="1" cols="75" style=" display: inline">Key here!</textarea>
    </div>
    <div class="inline">
        <button onclick="otp(true)">OTP-encrypt</button>
        <button onclick="otp(false)">OTP-decrypt</button>
        <button onclick="sha512()">SHA-2</button>
        <button onclick="md5_decrypt()">MD5 decrypt</button>
    </div>
    <div>
        <h4>Output:</h4>
        <textarea id="output" rows="10" cols="80">Output...</textarea>
    </div>
</body>
</html>